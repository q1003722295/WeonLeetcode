'''
给定一个未排序的整数数组，找出其中没有出现的最小的正整数。

示例 1:

输入: [1,2,0]
输出: 3
示例 2:

输入: [3,4,-1,1]
输出: 2
示例 3:

输入: [7,8,9,11,12]
输出: 1
说明:

你的算法的时间复杂度应为O(n)，并且只能使用常数级别的空间。

'''
'''
参考代码：https://leetcode-cn.com/problems/first-missing-positive/solution/tong-pai-xu-python-dai-ma-by-liweiwei1419/

桶排序的思想！！！！
因为没有出现的最小的正整数只可能在1~n之间（n为数组大小）！！ 想到这点就可以先进行就地桶排序 就很容易找出该值！

我们可以把数组进行一次“排序”，“排序”的规则是：如果这个数字 i 落在“区间范围里”，i 就应该放在索引为 i - 1 的位置上，下面具体解释。

1、数字 i 落在“区间范围里”；

例如：[3, 4, -1, 1]，一共 4 个数字，那么如果这个数组中出现 “1”、“2”、“3”、“4”，就是我们重点要关注的数字了；
又例如：[7, 8, 9, 11, 12] 一共 5 个数字，每一个都不是 “1”、“2”、“3”、“4”、“5” 中的一个，因此我们无须关注它们；

2、i 就应该放在索引为i - 1 的位置上；

这句话也可以这么说 “索引为 i 的位置上应该存放的数字是 i + 1”。

就看上面那张图，数字 1 应该放在索引为 0 的位置上，数字 3 应该放在索引为 2 的位置上，数字 4 应该放在索引为 3 的位置上。一个数字放在它应该放的位置上，我们就认为这个位置是“和谐”的，看起来“顺眼”的。

按照以上规则排好序以后，缺失的第 1 个正数一下子就看出来了，那么“最不和谐”的数字的索引 +1，就为所求。那如果所有的数字都“和谐”，数组的长度 +1 就为所求。

复杂度分析：

时间复杂度：O(N)，这里 N 是数组的长度，其实只要看这个数组一遍，就可以知道每个数字应该放在哪个位置，所以时间复杂度是 O(N)。
空间复杂度：O(1)，桶排序在原地进行，没有使用额外的存储空间。

优秀!

'''

class Solution:

    # 3 应该放在索引为 2 的地方
    # 4 应该放在索引为 3 的地方

    def firstMissingPositive(self, nums):
        size = len(nums)
        for i in range(size):
            # 先判断这个数字是不是索引，然后判断这个数字是不是放在了正确的地方
            while 1 <= nums[i] <= size and nums[i] != nums[nums[i] - 1]:
                self.__swap(nums, i, nums[i] - 1)

        for i in range(size):
            if i + 1 != nums[i]:
                return i + 1

        return size + 1

    def __swap(self, nums, index1, index2):
        nums[index1], nums[index2] = nums[index2], nums[index1]


s = Solution()
print(s.firstMissingPositive([1, 1]))
